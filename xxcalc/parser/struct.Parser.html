<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `Parser` struct in crate `xxcalc`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, Parser">

    <title>xxcalc::parser::Parser - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='../index.html'>xxcalc</a>::<wbr><a href='index.html'>parser</a></p><script>window.sidebarCurrent = {name: 'Parser', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='../index.html'>xxcalc</a>::<wbr><a href='index.html'>parser</a>::<wbr><a class='struct' href=''>Parser</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-324' class='srclink' href='../../src/xxcalc/src/parser.rs.html#78-81' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct Parser { /* fields omitted */ }</pre><div class='docblock'><p><code>Parser</code> takes <code>Tokens</code> in infix form and transforms them into
Reverse Polish Notation. After such transformation tokens
can be processed by <code>TokensReducer</code>.</p>

<p>Parser stores registered operators (with their precedence and
associativity) between multiple executions. Furthermore an
output buffer of <code>Tokens</code> is kept internally, so it can be reused
without allocating new memory from the operating system. If
Parser lives long enough this behaviour can greatly reduce
time wasted on mallocs.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>tokenizer</span> <span class='op'>=</span> <span class='ident'>Tokenizer</span>::<span class='ident'>default</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>parser</span> <span class='op'>=</span> <span class='ident'>Parser</span>::<span class='ident'>default</span>();

<span class='ident'>parser</span>.<span class='ident'>register_operator</span>(<span class='string'>&#39;+&#39;</span>, <span class='ident'>Operator</span>::<span class='ident'>new</span>(<span class='number'>1</span>, <span class='ident'>OperatorAssociativity</span>::<span class='ident'>Left</span>));

<span class='kw'>let</span> <span class='ident'>tokenized</span> <span class='op'>=</span> <span class='ident'>tokenizer</span>.<span class='ident'>process</span>(<span class='string'>&quot;2+2&quot;</span>);
<span class='kw'>let</span> <span class='ident'>parsed</span> <span class='op'>=</span> <span class='ident'>parser</span>.<span class='ident'>process</span>(<span class='ident'>tokenized</span>).<span class='ident'>unwrap</span>();

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>parsed</span>.<span class='ident'>tokens</span>, [(<span class='number'>0</span>, <span class='ident'>Token</span>::<span class='ident'>Number</span>(<span class='number'>2.0</span>)),
                           (<span class='number'>2</span>, <span class='ident'>Token</span>::<span class='ident'>Number</span>(<span class='number'>2.0</span>)),
                           (<span class='number'>1</span>, <span class='ident'>Token</span>::<span class='ident'>Operator</span>(<span class='string'>&#39;+&#39;</span>))]);<a class='test-arrow' target='_blank' href=''>Run</a></pre>

<h1 id='extending' class='section-header'><a href='#extending'>Extending</a></h1>
<p>One could embed the parser inside another <code>TokensProcessor</code> and initialize
it there with some default operators.</p>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><span class='in-band'><code>impl <a class='struct' href='../../xxcalc/parser/struct.Parser.html' title='xxcalc::parser::Parser'>Parser</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-344' class='srclink' href='../../src/xxcalc/src/parser.rs.html#272-328' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.new' class='method'><span id='new.v' class='invisible'><code>fn <a href='#method.new' class='fnname'>new</a>() -&gt; <a class='struct' href='../../xxcalc/parser/struct.Parser.html' title='xxcalc::parser::Parser'>Parser</a></code></span></h4>
<div class='docblock'><p>Creates an empty Parser with no defined operators.</p>
</div><h4 id='method.register_operator' class='method'><span id='register_operator.v' class='invisible'><code>fn <a href='#method.register_operator' class='fnname'>register_operator</a>(&amp;mut self, name: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.char.html'>char</a>, operator: <a class='struct' href='../../xxcalc/parser/struct.Operator.html' title='xxcalc::parser::Operator'>Operator</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../../xxcalc/parser/struct.Operator.html' title='xxcalc::parser::Operator'>Operator</a>&gt;</code></span></h4>
<div class='docblock'><p>Registers operator identified by given name to the parser.</p>

<p>Each operator must be registered and associated with its
precedence and associative to make parser capable of valid
RPN transformation. As operators always require two arguments,
no arity is needed.</p>

<p>If an operator with given name was already registered, it
previous specification is returned.</p>

<h1 id='examples-1' class='section-header'><a href='#examples-1'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>tokenizer</span> <span class='op'>=</span> <span class='ident'>Tokenizer</span>::<span class='ident'>default</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>parser</span> <span class='op'>=</span> <span class='ident'>Parser</span>::<span class='ident'>default</span>();

<span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='ident'>parser</span>.<span class='ident'>register_operator</span>(<span class='string'>&#39;+&#39;</span>, <span class='ident'>Operator</span>::<span class='ident'>new</span>(<span class='number'>42</span>, <span class='ident'>OperatorAssociativity</span>::<span class='ident'>Left</span>));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>r</span>.<span class='ident'>is_none</span>());

<span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='ident'>parser</span>.<span class='ident'>register_operator</span>(<span class='string'>&#39;+&#39;</span>, <span class='ident'>Operator</span>::<span class='ident'>new</span>(<span class='number'>1</span>, <span class='ident'>OperatorAssociativity</span>::<span class='ident'>Left</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>r</span>.<span class='ident'>unwrap</span>(), <span class='ident'>Operator</span>::<span class='ident'>new</span>(<span class='number'>42</span>, <span class='ident'>OperatorAssociativity</span>::<span class='ident'>Left</span>));
<a class='test-arrow' target='_blank' href=''>Run</a></pre>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><span class='in-band'><code>impl <a class='trait' href='https://doc.rust-lang.org/nightly/core/default/trait.Default.html' title='core::default::Default'>Default</a> for <a class='struct' href='../../xxcalc/parser/struct.Parser.html' title='xxcalc::parser::Parser'>Parser</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-327' class='srclink' href='../../src/xxcalc/src/parser.rs.html#89-93' title='goto source code'>[src]</a></span></h3>
<div class='docblock'><p>Creates a new default Parser.</p>

<p>Such parser is not ready to parse complex infix notation
by default. No operators are registered by default, one
must define operators with their precedence and associativity
to be able of parsing complex mathematical expressions.</p>
</div><div class='impl-items'><h4 id='method.default' class='method'><span id='default.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default' class='fnname'>default</a>() -&gt; <a class='struct' href='../../xxcalc/parser/struct.Parser.html' title='xxcalc::parser::Parser'>Parser</a></code></span></h4>
<div class='docblock'><p>Returns the &quot;default value&quot; for a type. <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default">Read more</a></p>
</div></div><h3 class='impl'><span class='in-band'><code>impl <a class='trait' href='../../xxcalc/trait.TokensProcessor.html' title='xxcalc::TokensProcessor'>TokensProcessor</a> for <a class='struct' href='../../xxcalc/parser/struct.Parser.html' title='xxcalc::parser::Parser'>Parser</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-329' class='srclink' href='../../src/xxcalc/src/parser.rs.html#185-270' title='goto source code'>[src]</a></span></h3>
<div class='docblock'><p>This is a main processing unit in the parser. It takes
a tokens in infix form and converts them to RPN using
Dijsktra&#39;s shunting-yard algorithm.</p>

<p>Before processing expressions more complex than trivial
identifiers or numbers, operators must be registered.</p>

<p>This parser supports two argument operators and multiple
argument functions. Function arguments must be declared
between opening and closing bracket tokens, with their
arguments separated using separator token.</p>

<p>A popular Dijsktra&#39;s <a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm">shunting-yard algorithm</a> converts
infix to postfix notation (RPN) in a linear time O(n). It
pushes numbers and constants to the output, while using
a stack to store temporary operands until they are needed
to be pushed to the output as some other operator with smaller
precedence is found.</p>

<h1 id='errors' class='section-header'><a href='#errors'>Errors</a></h1>
<p>An <code>EmptyExpression</code> error is returned when tokens represent
no meaningful expression (no tokens or just brackets).</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>parser</span> <span class='op'>=</span> <span class='ident'>Parser</span>::<span class='ident'>default</span>();

<span class='kw'>let</span> <span class='ident'>tokenized</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>Tokens</span>::<span class='ident'>new</span>(<span class='prelude-val'>None</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>parser</span>.<span class='ident'>process</span>(<span class='ident'>tokenized</span>).<span class='ident'>unwrap_err</span>(), <span class='ident'>ParsingError</span>::<span class='ident'>EmptyExpression</span>);<a class='test-arrow' target='_blank' href=''>Run</a></pre>

<p>A <code>MissingBracket</code> error is returned when brackets are unbalanced,
no matter if they were used to mark subexpression or an argument
list.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>tokenizer</span> <span class='op'>=</span> <span class='ident'>Tokenizer</span>::<span class='ident'>default</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>parser</span> <span class='op'>=</span> <span class='ident'>Parser</span>::<span class='ident'>default</span>();

{
  <span class='kw'>let</span> <span class='ident'>tokenized</span> <span class='op'>=</span> <span class='ident'>tokenizer</span>.<span class='ident'>process</span>(<span class='string'>&quot;(2&quot;</span>);
  <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>parser</span>.<span class='ident'>process</span>(<span class='ident'>tokenized</span>).<span class='ident'>unwrap_err</span>(), <span class='ident'>ParsingError</span>::<span class='ident'>MissingBracket</span>(<span class='number'>0</span>));
}

{
  <span class='kw'>let</span> <span class='ident'>tokenized</span> <span class='op'>=</span> <span class='ident'>tokenizer</span>.<span class='ident'>process</span>(<span class='string'>&quot;2)&quot;</span>);
  <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>parser</span>.<span class='ident'>process</span>(<span class='ident'>tokenized</span>).<span class='ident'>unwrap_err</span>(), <span class='ident'>ParsingError</span>::<span class='ident'>MissingBracket</span>(<span class='number'>1</span>));
}

{
  <span class='kw'>let</span> <span class='ident'>tokenized</span> <span class='op'>=</span> <span class='ident'>tokenizer</span>.<span class='ident'>process</span>(<span class='string'>&quot;foo(2, (2), -1&quot;</span>);
  <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>parser</span>.<span class='ident'>process</span>(<span class='ident'>tokenized</span>).<span class='ident'>unwrap_err</span>(), <span class='ident'>ParsingError</span>::<span class='ident'>MissingBracket</span>(<span class='number'>3</span>));
}<a class='test-arrow' target='_blank' href=''>Run</a></pre>

<p>An <code>UnexpectedToken</code> error is returned when parser encounters a token
with no meaning to the algorithm (such as <code>Token::Unknown</code>).</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>tokenizer</span> <span class='op'>=</span> <span class='ident'>Tokenizer</span>::<span class='ident'>default</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>parser</span> <span class='op'>=</span> <span class='ident'>Parser</span>::<span class='ident'>default</span>();

<span class='comment'>// note that @ is not a valid operator, so it results in Token::Unknown</span>
<span class='kw'>let</span> <span class='ident'>tokenized</span> <span class='op'>=</span> <span class='ident'>tokenizer</span>.<span class='ident'>process</span>(<span class='string'>&quot;(2)@2&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>parser</span>.<span class='ident'>process</span>(<span class='ident'>tokenized</span>).<span class='ident'>unwrap_err</span>(), <span class='ident'>ParsingError</span>::<span class='ident'>UnexpectedToken</span>(<span class='ident'>Token</span>::<span class='ident'>Unknown</span>(<span class='string'>&#39;@&#39;</span>), <span class='number'>3</span>));<a class='test-arrow' target='_blank' href=''>Run</a></pre>

<p>An <code>UnknownOperator</code> error is returned when a parser encounters an operator
token, but this operator is not registerd with the parser.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>tokenizer</span> <span class='op'>=</span> <span class='ident'>Tokenizer</span>::<span class='ident'>default</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>parser</span> <span class='op'>=</span> <span class='ident'>Parser</span>::<span class='ident'>default</span>();

<span class='kw'>let</span> <span class='ident'>tokenized</span> <span class='op'>=</span> <span class='ident'>tokenizer</span>.<span class='ident'>process</span>(<span class='string'>&quot;(2)+2&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>parser</span>.<span class='ident'>process</span>(<span class='ident'>tokenized</span>).<span class='ident'>unwrap_err</span>(), <span class='ident'>ParsingError</span>::<span class='ident'>UnknownOperator</span>(<span class='string'>&#39;+&#39;</span>, <span class='number'>3</span>));<a class='test-arrow' target='_blank' href=''>Run</a></pre>
</div><div class='impl-items'><h4 id='method.process' class='method'><span id='process.v' class='invisible'><code>fn <a href='../../xxcalc/trait.TokensProcessor.html#tymethod.process' class='fnname'>process</a>(&amp;mut self, tokens: &amp;<a class='struct' href='../../xxcalc/struct.Tokens.html' title='xxcalc::Tokens'>Tokens</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;&amp;<a class='struct' href='../../xxcalc/struct.Tokens.html' title='xxcalc::Tokens'>Tokens</a>,&nbsp;<a class='enum' href='../../xxcalc/enum.ParsingError.html' title='xxcalc::ParsingError'>ParsingError</a>&gt;</code></span></h4>
</div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "xxcalc";
        window.playgroundUrl = "";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    
    <script defer src="../../search-index.js"></script>
</body>
</html>